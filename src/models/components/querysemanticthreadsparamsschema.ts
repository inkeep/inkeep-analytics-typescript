/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AggregationSelection,
  AggregationSelection$inboundSchema,
  AggregationSelection$Outbound,
  AggregationSelection$outboundSchema,
} from "./aggregationselection.js";
import {
  GroupByItemSchema,
  GroupByItemSchema$inboundSchema,
  GroupByItemSchema$Outbound,
  GroupByItemSchema$outboundSchema,
} from "./groupbyitemschema.js";
import {
  OrderBySchema,
  OrderBySchema$inboundSchema,
  OrderBySchema$Outbound,
  OrderBySchema$outboundSchema,
} from "./orderbyschema.js";
import {
  SemanticThreadFilter,
  SemanticThreadFilter$inboundSchema,
  SemanticThreadFilter$Outbound,
  SemanticThreadFilter$outboundSchema,
} from "./semanticthreadfilter.js";
import {
  SimpleFieldSelection,
  SimpleFieldSelection$inboundSchema,
  SimpleFieldSelection$Outbound,
  SimpleFieldSelection$outboundSchema,
} from "./simplefieldselection.js";
import {
  TimeBasedGroupBySelection,
  TimeBasedGroupBySelection$inboundSchema,
  TimeBasedGroupBySelection$Outbound,
  TimeBasedGroupBySelection$outboundSchema,
} from "./timebasedgroupbyselection.js";

/**
 * Either an aggregation, time based group by, or a simple field
 */
export type SelectionSchema =
  | (SimpleFieldSelection & { type: "field" })
  | (AggregationSelection & { type: "aggregation" })
  | (TimeBasedGroupBySelection & { type: "time" });

export type QuerySemanticThreadsParamsSchema = {
  select?:
    | Array<
      | (SimpleFieldSelection & { type: "field" })
      | (AggregationSelection & { type: "aggregation" })
      | (TimeBasedGroupBySelection & { type: "time" })
    >
    | undefined;
  groupBy?: Array<GroupByItemSchema> | undefined;
  where?: SemanticThreadFilter | undefined;
  orderBy?: Array<OrderBySchema> | undefined;
  /**
   * Notes for the query
   */
  notes?: string | undefined;
};

/** @internal */
export const SelectionSchema$inboundSchema: z.ZodType<
  SelectionSchema,
  z.ZodTypeDef,
  unknown
> = z.union([
  SimpleFieldSelection$inboundSchema.and(
    z.object({ type: z.literal("field") }).transform((v) => ({ type: v.type })),
  ),
  AggregationSelection$inboundSchema.and(
    z.object({ type: z.literal("aggregation") }).transform((v) => ({
      type: v.type,
    })),
  ),
  TimeBasedGroupBySelection$inboundSchema.and(
    z.object({ type: z.literal("time") }).transform((v) => ({ type: v.type })),
  ),
]);

/** @internal */
export type SelectionSchema$Outbound =
  | (SimpleFieldSelection$Outbound & { type: "field" })
  | (AggregationSelection$Outbound & { type: "aggregation" })
  | (TimeBasedGroupBySelection$Outbound & { type: "time" });

/** @internal */
export const SelectionSchema$outboundSchema: z.ZodType<
  SelectionSchema$Outbound,
  z.ZodTypeDef,
  SelectionSchema
> = z.union([
  SimpleFieldSelection$outboundSchema.and(
    z.object({ type: z.literal("field") }).transform((v) => ({ type: v.type })),
  ),
  AggregationSelection$outboundSchema.and(
    z.object({ type: z.literal("aggregation") }).transform((v) => ({
      type: v.type,
    })),
  ),
  TimeBasedGroupBySelection$outboundSchema.and(
    z.object({ type: z.literal("time") }).transform((v) => ({ type: v.type })),
  ),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SelectionSchema$ {
  /** @deprecated use `SelectionSchema$inboundSchema` instead. */
  export const inboundSchema = SelectionSchema$inboundSchema;
  /** @deprecated use `SelectionSchema$outboundSchema` instead. */
  export const outboundSchema = SelectionSchema$outboundSchema;
  /** @deprecated use `SelectionSchema$Outbound` instead. */
  export type Outbound = SelectionSchema$Outbound;
}

export function selectionSchemaToJSON(
  selectionSchema: SelectionSchema,
): string {
  return JSON.stringify(SelectionSchema$outboundSchema.parse(selectionSchema));
}

export function selectionSchemaFromJSON(
  jsonString: string,
): SafeParseResult<SelectionSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SelectionSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SelectionSchema' from JSON`,
  );
}

/** @internal */
export const QuerySemanticThreadsParamsSchema$inboundSchema: z.ZodType<
  QuerySemanticThreadsParamsSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  select: z.array(
    z.union([
      SimpleFieldSelection$inboundSchema.and(
        z.object({ type: z.literal("field") }).transform((v) => ({
          type: v.type,
        })),
      ),
      AggregationSelection$inboundSchema.and(
        z.object({ type: z.literal("aggregation") }).transform((v) => ({
          type: v.type,
        })),
      ),
      TimeBasedGroupBySelection$inboundSchema.and(
        z.object({ type: z.literal("time") }).transform((v) => ({
          type: v.type,
        })),
      ),
    ]),
  ).optional(),
  groupBy: z.array(GroupByItemSchema$inboundSchema).optional(),
  where: SemanticThreadFilter$inboundSchema.optional(),
  orderBy: z.array(OrderBySchema$inboundSchema).optional(),
  notes: z.string().optional(),
});

/** @internal */
export type QuerySemanticThreadsParamsSchema$Outbound = {
  select?:
    | Array<
      | (SimpleFieldSelection$Outbound & { type: "field" })
      | (AggregationSelection$Outbound & { type: "aggregation" })
      | (TimeBasedGroupBySelection$Outbound & { type: "time" })
    >
    | undefined;
  groupBy?: Array<GroupByItemSchema$Outbound> | undefined;
  where?: SemanticThreadFilter$Outbound | undefined;
  orderBy?: Array<OrderBySchema$Outbound> | undefined;
  notes?: string | undefined;
};

/** @internal */
export const QuerySemanticThreadsParamsSchema$outboundSchema: z.ZodType<
  QuerySemanticThreadsParamsSchema$Outbound,
  z.ZodTypeDef,
  QuerySemanticThreadsParamsSchema
> = z.object({
  select: z.array(
    z.union([
      SimpleFieldSelection$outboundSchema.and(
        z.object({ type: z.literal("field") }).transform((v) => ({
          type: v.type,
        })),
      ),
      AggregationSelection$outboundSchema.and(
        z.object({ type: z.literal("aggregation") }).transform((v) => ({
          type: v.type,
        })),
      ),
      TimeBasedGroupBySelection$outboundSchema.and(
        z.object({ type: z.literal("time") }).transform((v) => ({
          type: v.type,
        })),
      ),
    ]),
  ).optional(),
  groupBy: z.array(GroupByItemSchema$outboundSchema).optional(),
  where: SemanticThreadFilter$outboundSchema.optional(),
  orderBy: z.array(OrderBySchema$outboundSchema).optional(),
  notes: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QuerySemanticThreadsParamsSchema$ {
  /** @deprecated use `QuerySemanticThreadsParamsSchema$inboundSchema` instead. */
  export const inboundSchema = QuerySemanticThreadsParamsSchema$inboundSchema;
  /** @deprecated use `QuerySemanticThreadsParamsSchema$outboundSchema` instead. */
  export const outboundSchema = QuerySemanticThreadsParamsSchema$outboundSchema;
  /** @deprecated use `QuerySemanticThreadsParamsSchema$Outbound` instead. */
  export type Outbound = QuerySemanticThreadsParamsSchema$Outbound;
}

export function querySemanticThreadsParamsSchemaToJSON(
  querySemanticThreadsParamsSchema: QuerySemanticThreadsParamsSchema,
): string {
  return JSON.stringify(
    QuerySemanticThreadsParamsSchema$outboundSchema.parse(
      querySemanticThreadsParamsSchema,
    ),
  );
}

export function querySemanticThreadsParamsSchemaFromJSON(
  jsonString: string,
): SafeParseResult<QuerySemanticThreadsParamsSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QuerySemanticThreadsParamsSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QuerySemanticThreadsParamsSchema' from JSON`,
  );
}
